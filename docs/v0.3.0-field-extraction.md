# ðŸ“˜ v0.3.0 Development Document: Field Extraction API

> **Status**: âœ… Completed  
> **Estimated Time**: 1 week  
> **Dependencies**: v0.2.0 recommended (can work independently)

---

## 1. Overview

### 1.1 Goal
Implement `lootField` function to extract specific fields without parsing the entire document.

### 1.2 Use Cases
- When only specific fields are needed from large JSON
- When parsing performance is critical
- As a lightweight alternative to streaming parsing

### 1.3 Scope of Changes
| File | Change Type |
|------|-------------|
| `src/lootField.ts` | New file |
| `src/types.ts` | Modified (type additions) |
| `src/index.ts` | Modified (export additions) |

---

## 2. API Design

### 2.1 Function Signature

```typescript
function lootField<T = unknown>(
  text: string,
  path: string,
  options?: LootFieldOptions
): T | T[] | undefined;
```

### 2.2 Options

```typescript
interface LootFieldOptions {
  repair?: boolean;  // Default: true
  silent?: boolean;  // Default: true
  all?: boolean;     // Default: false
}
```

### 2.3 Usage Examples

```typescript
import { lootField } from 'loot-json';

// Simple field
const name = lootField<string>(text, 'name');

// Nested field (dot notation)
const city = lootField(text, 'user.address.city');

// Bracket notation for special keys
const value = lootField(text, 'data["special.key"]');

// Get all occurrences
const allNames = lootField(text, 'name', { all: true });
```

---

## 3. Implementation Strategy

### 3.1 Approach
Hybrid approach:
1. Use regex to locate field position
2. Parse only the value at that position

### 3.2 Algorithm

```
lootField(text, "user.profile.name")
    â”‚
    â–¼
1. Extract JSON candidates (reuse extractors.ts)
    â”‚
    â–¼
2. Split path: ["user", "profile", "name"]
    â”‚
    â–¼
3. Find first key "user"
   - Pattern: /"user"\s*:\s*/
    â”‚
    â–¼
4. Determine value range at that position
   - { for object, [ for array, " for string
    â”‚
    â–¼
5. Extract and recurse for next key "profile"
    â”‚
    â–¼
6. Extract final value "name" and parse
    â”‚
    â–¼
7. Return parsed value
```

---

## 4. Test Cases

```typescript
describe('lootField', () => {
  it('should extract string field', () => {
    expect(lootField('{"name": "sword"}', 'name')).toBe('sword');
  });

  it('should extract nested field', () => {
    const json = '{"user": {"profile": {"name": "John"}}}';
    expect(lootField(json, 'user.profile.name')).toBe('John');
  });

  it('should handle bracket notation', () => {
    const json = '{"a.b": {"c": 1}}';
    expect(lootField(json, '["a.b"].c')).toBe(1);
  });

  it('should return undefined for missing field', () => {
    expect(lootField('{"a": 1}', 'b')).toBeUndefined();
  });
});
```

---

## 5. Edge Cases

| Case | Input | Expected |
|------|-------|----------|
| Empty string value | `{"a": ""}` â†’ `lootField(_, 'a')` | `""` |
| null value | `{"a": null}` â†’ `lootField(_, 'a')` | `null` |
| 0 value | `{"a": 0}` â†’ `lootField(_, 'a')` | `0` |
| false value | `{"a": false}` â†’ `lootField(_, 'a')` | `false` |
| Empty array | `{"a": []}` â†’ `lootField(_, 'a')` | `[]` |
| Empty object | `{"a": {}}` â†’ `lootField(_, 'a')` | `{}` |

---

## 6. Notes

### 6.1 Backward Compatibility
- New function addition, no impact on existing API

### 6.2 Future Extensions
- Array index access: `items[0].name`
- Wildcards: `users.*.name`
