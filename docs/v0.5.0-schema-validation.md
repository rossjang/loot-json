# üìò v0.5.0 Development Document: JSON Schema Validation

> **Status**: ‚úÖ Completed  
> **Estimated Time**: 2 weeks  
> **Dependencies**: v0.4.0 recommended  
> **Priority**: ‚≠ê‚≠ê Medium

---

## 1. Overview

### 1.1 Goal
Implement a lightweight JSON Schema validator for validating extracted JSON structure.

### 1.2 Design Principles
- **Zero Dependency**: No external libraries (ajv, zod, etc.)
- **Lightweight Implementation**: Support only essential features
- **Practicality**: Focus on features needed for LLM output validation

### 1.3 Scope of Changes
| File | Change Type |
|------|-------------|
| `src/schema/index.ts` | New file |
| `src/schema/validator.ts` | New file |
| `src/schema/types.ts` | New file |
| `src/types.ts` | Modified (LootOptions extension) |
| `src/loot.ts` | Modified (schema validation integration) |
| `src/index.ts` | Modified (export additions) |

---

## 2. API Design

### 2.1 Standalone Validation

```typescript
import { validate } from 'loot-json';

const result = validate(data, {
  type: 'object',
  properties: {
    dialogue: { type: 'string', minLength: 1 },
    emotion: { type: 'string', enum: ['happy', 'sad', 'angry'] },
    affinity: { type: 'number', minimum: -10, maximum: 10 },
  },
  required: ['dialogue', 'emotion'],
});

if (result.valid) {
  console.log('Valid:', result.data);
} else {
  console.log('Errors:', result.errors);
}
```

### 2.2 Validation Result

```typescript
interface ValidationResult<T = unknown> {
  valid: boolean;
  data: T | null;
  errors: ValidationError[];
}

interface ValidationError {
  path: string;
  message: string;
  keyword: string;
  expected?: unknown;
  actual?: unknown;
}
```

---

## 3. Supported Schema Keywords

### 3.1 Feature Matrix

| Category | Keyword | Supported |
|----------|---------|-----------|
| **Type** | `type` | ‚úÖ |
| **Object** | `properties` | ‚úÖ |
| | `required` | ‚úÖ |
| | `additionalProperties` | ‚úÖ |
| **Array** | `items` | ‚úÖ |
| | `minItems`, `maxItems` | ‚úÖ |
| | `uniqueItems` | ‚úÖ |
| **String** | `minLength`, `maxLength` | ‚úÖ |
| | `pattern` | ‚úÖ |
| | `format` (basic) | ‚úÖ |
| **Number** | `minimum`, `maximum` | ‚úÖ |
| | `exclusiveMinimum`, `exclusiveMaximum` | ‚úÖ |
| | `multipleOf` | ‚úÖ |
| **Enum** | `enum` | ‚úÖ |
| | `const` | ‚úÖ |
| **Logical** | `allOf`, `anyOf`, `oneOf` | ‚ùå (v1.0.0) |
| | `not` | ‚ùå (v1.0.0) |
| **Reference** | `$ref` | ‚ùå |

### 3.2 Supported Formats

| Format | Description |
|--------|-------------|
| `date` | ISO 8601 date (YYYY-MM-DD) |
| `date-time` | RFC 3339 date-time |
| `email` | Email address |
| `uri` | URI |
| `uuid` | UUID v1-5 |

---

## 4. Implementation

### 4.1 SchemaValidator Class

```typescript
class SchemaValidator {
  validate<T>(data: unknown, schema: LootSchema): ValidationResult<T>;
}
```

Key methods:
- `validateType()`: Type validation
- `validateString()`: String constraints (length, pattern, format)
- `validateNumber()`: Number constraints (min, max, multipleOf)
- `validateObject()`: Object constraints (properties, required)
- `validateArray()`: Array constraints (items, length, unique)

### 4.2 Error Messages

| Keyword | Message Template |
|---------|-----------------|
| `type` | `Expected {expected}, got {actual}` |
| `required` | `Missing required property: {expected}` |
| `minLength` | `String must be at least {expected} characters` |
| `maxLength` | `String must be at most {expected} characters` |
| `minimum` | `Value must be >= {expected}` |
| `maximum` | `Value must be <= {expected}` |
| `enum` | `Value must be one of: {expected}` |

---

## 5. Test Cases

```typescript
describe('SchemaValidator', () => {
  it('should validate type', () => {
    expect(validate('hello', { type: 'string' }).valid).toBe(true);
    expect(validate(123, { type: 'string' }).valid).toBe(false);
  });

  it('should validate required properties', () => {
    const schema = {
      type: 'object',
      required: ['name', 'age'],
    };
    expect(validate({ name: 'John', age: 30 }, schema).valid).toBe(true);
    expect(validate({ name: 'John' }, schema).valid).toBe(false);
  });

  it('should report path in errors', () => {
    const schema = {
      type: 'object',
      properties: {
        user: {
          type: 'object',
          properties: {
            age: { type: 'number', minimum: 0 },
          },
        },
      },
    };
    const result = validate({ user: { age: -1 } }, schema);
    expect(result.errors[0].path).toBe('user.age');
  });
});
```

---

## 6. Complex Schema Example

```typescript
const schema = {
  type: 'object',
  properties: {
    dialogue: { type: 'string', minLength: 1 },
    emotion: {
      type: 'string',
      enum: ['happy', 'sad', 'angry', 'neutral'],
    },
    affinity: {
      type: 'number',
      minimum: -10,
      maximum: 10,
    },
    actions: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          type: { type: 'string' },
          target: { type: 'string' },
        },
        required: ['type'],
      },
    },
  },
  required: ['dialogue', 'emotion'],
};

const result = validate(llmOutput, schema);
```

---

## 7. Notes

### 7.1 Zero Dependency
- No external JSON Schema libraries used
- All validation logic self-implemented

### 7.2 Performance
- Most LLM outputs are small JSON
- Prioritize code clarity over complex optimization

### 7.3 Future Extensions
- `allOf`, `anyOf`, `oneOf` support (v1.0.0)
- Custom format registration
- Async validation (external API calls)
